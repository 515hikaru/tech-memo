#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: post
#+author: 515hikaru

* Blog Entries
  :PROPERTIES:
  :VISIBILITY: children
  :END:

** DONE Dockerって難しくね :Docker:Working:
   :PROPERTIES:
   :EXPORT_FILE_NAME: 2020-06-26-docker-is-difficult
   :EXPORT_DATE: 2020-06-26T00:00:00+09:00
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :toc true
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :stylesheet "post.css"
   :END:

*** Docker 勉強会

この間 Docker について会社の人の前で話す機会があって Docker の基本的なことについて話しました。で思ったんだけど、 Docker って難しくないですか。改めて。

例えば仮想化に関する話をしようとすると、完全仮想化（e.g. VirtualBox）や準仮想化（e.g. Hyper-V）とコンテナ型仮想化の違いとか、systemd-nspawn と Docker って何がちゃうんやろとか[fn:1]。ではアプリケーションコンテナってなんやとか、Registry/Image/Container と pull/build/run/exec/push などの各コマンドがどう関連しているのかとか（つまりはこのコマンドは何に対してどんな操作をするのかとか）。 =docker= コマンドの体系複雑すぎないとか。

[fn:1] これを書いている筆者も知りません。


自分がイチから Docker を学んだときってどう学んだっけな、って考えると正直真面目に学んだ記憶がない。だけどいつの間にか Docker の思想を内面化していて、できるようになっていったんですよね。それは才能とかセンスとかではなくて、誰かが教えてくれたり、「こうしたほうが楽じゃん」に遠回りして気づいたり、というのを長い時間かけてやってきたからだと思う。

あまりにも当たり前過ぎて Docker を使うの別に難しくないじゃんくらいに思っていたんだけど、改めて自分が知っていることを書き出してみたらなんとまぁ多いこと。もちろん知らないこともいっぱいあるし、 =docker run -i= と =docker run -it= の違いを説明せよとか言われたらちょっと勘弁してくれって思う。だけどそんな僕でも Docker はそこそこ使えるなって実感があるし、そのそこそこ使えるぞにたどり着くまでにかかった時間って決して短くない（最低半年はかかってる）。

*** Docker の難しさ

Docker がなんで難しいかって、結局アプリケーションのものだからだと思う。

それ以前は開発環境にせよ本番環境にせよ環境はポータブルではないので、環境とアプリケーションがある意味で切り離されていた。Windows で動く Web アプリケーションが Linux でも動くとは限らないので Linux サーバーを立ててデプロイしてみて動くやんけ動かんやんけとワイワイやって、頑張ってサーバー起動してうんぬんということをしていたわけだ。でもそれはアプリケーションの開発とは全く別枠として行われていた。

一方で、 Docker は Dockerfile だとかでラップしているけれど、ある種むき出しのインフラが、語弊を承知で言うとむき出しの Linux がアプリケーションエンジニアの前に表出している状態ではある。僕はちょっと変な人なのでデスクトップ Linux を常用しているし[fn:2]、 =apt-get= も =dnf= も =pacman= もなんでもござれ、シェルとか環境変数とか慣れっこな人だけど、普通の人はそうではない。

[fn:2] このブログも ThinkPad T480s にインストールした Ubuntu 20.04 で書いている。


Docker の登場で、アプリケーションがアプリケーションを動作する環境を規定することが簡単にできるようになった。例えば [[https://github.com/hadolint/hadolint][hadolint]] とかはすごい。コマンドラインツールだが、標準入力を受け取るだけなので、コンテナの中で全てが完結する[fn:3]。hadolint の実行環境は hadolint の開発者の一存で決められるし、環境を変えてもユーザーになんの影響もない。これは本当にすごいことだ。

[fn:3] ちなみに hadolint は Dockerfile の Lint ツールなので Docker がインストールされていることを前提にしてよい、という大前提があってこれが成立している。


もちろん Web サービスであれば、本番環境で動かすなら ECS だとか Kubernetes だとか Nomad だとか Swarm だとか、考えるべきところはいろいろある。だけどそこまで行くとインフラエンジニアと協業する枠で、アプリケーションエンジニアだけのものという感覚がない、と個人的には感じる。

一方で、Docker は既に完全にアプリケーションのものだと思う。アプリケーションの実行環境はアプリケーションが規定するべきだし、そのコストは Docker を学ぶこと以外存在しない。アプリケーションの実行環境はインフラエンジニアが「用意するもの」ではなく、開発者が自分たちで「規定するもの」であり、そして変化するソフトウェアの一部になっている。何年か前から。

*** 唯一の障壁

ただ、残念ながら Docker は難しい。改めて思った。

勉強会では、仮想化についての話は一切しなかった。 =docker= コマンドの本当にごく一部、 =run=, =exec=, =pull=, =ps=, =images=, =prune= などについて簡単な解説をしたが、それでも十分大変だった。

Git の難しさと似ている。それができれば何ができるのか、よくわかっている人には当たり前なんだけどその凄みを伝えるのは難しいと感じる。たとえばさっきの hadolint ってめちゃくちゃすごいと思うし、Docker があればこそ成立する配布方法なのだが、それをすごいと思ってくれる人は既に Docker の凄さをわかっている人だと思う。

空気のように存在しているものは、それが当たり前すぎて却ってその凄みを感じづらい。昔クラスがある言語を使うことはあらゆる言語がクラスをサポートするほどには先進的だったのだろうけど、今はそれが当たり前すぎてクラスがない言語を触ると「なんでないの？」と思うことだろう。それが例えば Git であり、 Docker であるのだと思う。わたしはバックエンド側の人間だからよく知らないけど、仮想 DOM とかもそういう存在になりつつある（もうなっている？）のではないか。

あとコンテナを軽い仮想マシンと思うとかえって使いづらいと感じると思う、という話は加算無限回しているけど、なんとなく軽い仮想マシンとして使っている人はまだこの世にいっぱいいそうな気がする。

*** 終わりに

ここまで書いてアプリケーションって書きまくったけどだいたい Web を想定していた。モバイルとかそういうのは想定していません。ごめんなさい。

何をすれば Docker をわかった気になるのか、ということを考えて、とりあえず用語の整理と基礎的なコマンドを紹介する、以上の手が浮かばなかった。たぶん Git 勉強会をやっても同じことを思う気がする。

価値が見えづらいものの価値を伝える、ということはすごく意義があることだと思うので僕は好きだ。だけど、楽な仕事かというと決してそうではない。なんとか Docker の価値を伝え続けていきたいなと感じてはいる。

そのうち Git についても小言を書こうかなと思ったり思わなかったり。

** DONE OSS に対するお気持ち表明                                        :OSS:
   :PROPERTIES:
   :EXPORT_FILE_NAME: 2020-06-27-thinking-about-OSS
   :EXPORT_DATE: 2020-06-27T17:00:00+09:00
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :stylesheet "post.css"
   :END:

お気持ちの表明です。それ以上でもそれ以下でもありません。

*** パクリについて

なんでこんな記事を書こうと思ったのかと言うと（もう結構前のことになってしまったが）、特定の OSS を改変したサイトなどに対してパクリと評したツイートがあった。それに対して過剰に批判したり、怒りを表明したりといったソフトウェアエンジニア、あるいは OSS に関する知識をある程度持っている人を何人か観測したからだ。

まず大前提として、わたし自身もソフトウェアエンジニアであり、OSS には日々接している。すべてはないが、個人で書いたコードの一部は MIT ライセンスなどのライセンスのもとで公開していることが多い。だから、例えば MIT ライセンスのもとで公開されている HTML/CSS のコードを再利用し、自身のホームページを製作しても法的には問題ないであろうということ[fn:1]は重々承知している。

[fn:1] 法律に反しているか否かは、本来は司法判断がなければわからないので、一般的には合法と判断されるであろうということと、合法であるということと、かつて合法であると判断された類似の案件が存在することは全て意味が異なる、ということに留意してこの表現にしている。


それではわたしが「パクリである」という誹りに怒りを覚えているかと言うと、実はそうでもない。それなりに仕方がないことだと思っている。

**** 「パクり」という言葉をいつ使うか

まず「パクリ」という言葉をいつ使うかを思い起こしてほしい。おそらく表象、プログラマっぽくいえばインターフェースを似せて作ったときに「パクった」という言葉を使うと思う。内部状態に関するコードがいくら似ていてもあんまりパクったとは思わない。むしろ全然違うオブジェクトを対象にしているにもかかわらず、API の JSON の形式を真似たときにパクったと言うのではないかと思う。

で、件の「パクリ」発言は何に対してなされたかというと、HP のデザインに対してなされたものだ。コードで言えば HTML/CSS(/JavaScript) に相当する内容だ。まさしく表象である。誰でも表象に対して似てる/似てないは判断できる。だからパクリだと言われたのだろう。

**** 「パクり」であることと「違法」であることは違う

そして、パクリとは本来「盗作だ」ということを意図した発言だと思われるかもしれないが、パクるという言葉自体はもっとカジュアルに使われている、と少なくともわたしは認識している。「MacBook Airをパクったデザインのラップトップ」で思い浮かぶ製品があるだろうが、決して Apple が訴訟を起こした商品ばかりではない。デザインが似ていること（一般人にはパクリに見えること）と、それが違法と判断されることには大きな乖離がある。

なので、「このサイトとこのサイトは似ている！パクリだ！」という主張に対して「MIT ライセンスのもとで公開されているソースコードを再利用なので問題ないですよ」というのはあまりに的外れな回答だとわたしは思う。パクリのように見えるけれども違法とは判断されていないことなんてこの世にたくさんあるが、だからといって全ての人間が違法ではないから問題はないと思うわけではない。たとえ作者が許可したのであってもデザインを似せるのはよくないと思うという価値観の人がいたとして不思議ではないし、その価値観自体には何の問題もない[fn:2]。何より、人は善とか悪とかを合法とか違法とかで判断しているのではない[fn:3]。その人ごとの基準で判断しているはずだ。

[fn:2] 思想・信条は自由である。


[fn:3] そもそも法は善や悪を定めるものではない。



*** OSS は自明ではない

まずパクリ発言が話題だったのでそれに対する見解を述べた。けど、正直わたしはこの話どうでも良いと思っている。それよりも、OSS という枠組みが決して自明なものではないにもかかわらず、自分たちの「常識」を他の人にも強要している姿勢のほうがずっと気にかかる。

**** 権利を放棄することの異常さ

ソフトウェアも創作物のひとつだ。小説を書いたときのように、絵や漫画を書いたときのように、音楽創ったときのように、あなたがソフトウェアを制作したならば、著作権は作者の意思に関係なくひっついてくる[fn:4]。そして権利を放棄することは、実は結構難しい。著作権や著作人格権については、国によって法律が違うなどの事情もある。

[fn:4] このブログ、実は文章に対してライセンスを明示していないが、原稿自体は GitHub に MIT ライセンス配下のリポジトリに置かれている。本当はブログ記事自体は Creative Commons にしようと思っているんだけど未だにやっていない。


[[https://creativecommons.jp/sciencecommons/aboutcc0/][CC0について ― “いかなる権利も保有しない” | クリエイティブ・コモンズ・ジャパン]]

そして OSS ライセンスというのは単に権利を放棄するのではなく、「一定の条件下でユーザーに改変・再配布を許諾するが、その代わり責任は負わない」という宣言がなされているものがほとんどである。すべての権利を放棄するわけではない。しかし、作者が自ら権利を放棄する行動である。

さて、皆さんの周りで作者としての権利を放棄したいと言っているソフトウェアエンジニア以外の人を見たことがあるだろうか。星野源？そんなこともあったね。

でもおそらくほとんど見たことがないのではないかと思う。わたしはプロのミュージシャンが「自分の曲を自由に編曲して！」って言っているのを星野源以外から聞いたことないし[fn:5]、画家、小説家、イラストレーター、映画監督、その他さまざまなクリエイターが自分の権利を放棄したいと言っているのを見たことは全くない。むしろ権利について厳格で、いざ盗作が起きたら訴訟沙汰にするのも辞さない勢いであることがほとんどだろう。

あとソフトウェアの世界でも、決して多いとは思わない。ソフトウェアをどのようなライセンスで配布するかは著作権者の一存でのみ決まるべきで、他の理由が介在してはならないと思う。ちなみにわたしの仕事もクローズドだ。もしソースコードを公開しようものなら即刻解雇だろう。

[fn:5] あれも問題のあるライセンスだとは思うが。


**** OSS の特殊性

ところが、ソフトウェアの世界では、その権利を放棄する流派がある程度の存在感を持っている。自分の権利をある程度放棄することが、社会のためになる、自分のためになると信じられる人がほかの業界よりも存在感を持っている。

これをどう評価するかは置いておくとして、これはソフトウェア業界（のさらにごく一部）でしかコンセンサスが得られていない事象だ。まずそう認識しなければならない。人類は権利を放棄する営みに慣れていない（だからあまりルールがないし慣れていない）。

とにかく OSS というのは常識から外れた営みだ。外れているからこそ、その文化を知らない人と接したときにていねいに接しなければならない。というか、ソフトウェアの世界でもこれが最初から当たり前ではまったくなかった。90年代に人々を熱狂させたのは Microsoft の Windows であり UNIX 文化ではなかった。OSI や FSF が何十年にも渡って啓蒙をし続け、テックジャイアントも OSS の重要性を認識し始め、ここまでのものになったという歴史があるだろう。

何十年もの歴史を引き継ごうという我々が、そしてオープンであることを是とする自分たちが、OSS を初めて知った人に対して怒ったり、非常識だと嘲って対立してどうするよ。むしろ今度は、我々が先人たちの偉業を引き継ぐ番だろう。

*** 終わりに

途中まで書いて放棄していた下書きに少し加筆して公開した、ただの気持ちを書いた記事です。特定の誰かを否定したいわけでもないし、特定の事件について書いたつもりはありません。

言いたいのは、以下の2つ。

- OSS 文化は特殊であると認識すること
- 特殊性を認識せずに立ち入った人たちに対してもオープンに振る舞い、自分たちが是とすることを伝え続けること
- 文化を知らない人たちと対立を煽るような言動は悪手だということ

わたしも OSS を使い始めて 3, 4 年経って初めて意味がわかり始めてきた。知らない人、直観的ではないと感じる人が居るのは当然だと思う。利用しながら正直よくわからんという人も大勢居るだろう。

OSS が公共性の高いソフトウェアやウェブサイトにまで活用され始めているのは良いことだと素直に思う。だからこの流れを崩さないためにも、少しではあっても OSS に関わり続けている人ができることを考えていきたい。そのためにすべきことは、OSS を知らない人を嘲笑うことでも、事態を誤認している人に怒りを表明することでも、対立を深めることでもないはずだ。

そんなことを考えている。

** TODO Git をどう使うか                                                :Git:
   :PROPERTIES:
   :EXPORT_FILE_NAME: 2020-07-13-how-to-use-git
   :EXPORT_DATE: 2020-07-13T23:00:00+09:00
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :stylesheet "post.css"
   :END:
   
*** Git の使い方

みなさん Git どう使います？

というのも、今日 Git の話になってふと考えたのです。Git ってもちろん分散型バージョン管理システムなので、個々人のローカルリポジトリをどう管理しているのかなんてわからないなと。

おそらく中央リポジトリとして使われている Git ホスティングサービス（GitHub, GitLab, Bitbucket etc...）での運用はチームなり組織なりで決まっているでしょうけど、そこで見えているのは Git を使っている一部の側面でしかないはずなんですよね。

で、人に聞く前に自分はどうしているんだろうなとシャワー浴びながら考えていたら、妙な使い方をしているなと自分でも思ったので少し書き出してみます。

*** 基本的な操作

ちなみに、先に例外として magit を使うケースを挙げておきます。magit は Emacs から Git 操作できる Emacs のパッケージです。ごく一部 Emacs で編集するプロジェクトがあって、そのリポジトリの Git 操作をするときは magit を使っています。このブログも Emacs で書いているので magit を使っています。ただ magit は diff/add(-p)/commit/push くらいにしか使わないです。

**** commit

コマンドラインでしかやりません。=git commit -m "commit message"= とうってコミットします。VSCode とかでコミットすることがないとは言いませんが、ごくまれです。

**** ブランチ切り替え

9割くらい =git switch= で。稀に VSCode でクリックして切り替えることも。

**** push/fetch

リモートリポジトリと通信するのはコマンドラインからやります。

#+BEGIN_SRC 
git fetch -p --all
git rebase origin/master
#+END_SRC

などとするのが常です。

**** diff/log

基本的には `git diff` や `git log` で足りるならそれで済ませます。ただいろんな diff を見たいときは =tig= コマンドを使うこともあります。

特に「どこまで add したっけ……？」とわからなくなることがよくあるので、 Staged diff をみるために =tig= を叩くことは多いです。

**** blame

GitHub で見ます。特に工夫はありません。

**** add

結構多岐に渡ります。基本は =git add -p .= をすることが多いです。1行だけ add したいときがまれにあり、そういうときは =tig= で =1= とうつと1行 add できるのでよく使います。

VSCode でも指定した範囲を add することができるので稀に使います。

**** 対話的 rebase

=git rebase -i= 一択です。すごい頻繁にやります。

**** コンフリクト解消

ほとんどの場合、コンフリクトするようなプロジェクトは複数人で開発する場合なのでコードベースも大きいことが多いです。ということで VSCode でコンフリクト解消します。

[[https://qiita.com/penpenta/items/08b59f4b788ca2ae1c07#3-merge%E3%81%97%E3%81%9F%E9%9A%9B%E3%81%ABbranch_b%E4%B8%8A%E3%81%A7conflict%E3%81%8C%E7%99%BA%E7%94%9F%E3%81%97%E3%81%A6vscode%E4%B8%8A%E3%81%A7%E7%A2%BA%E8%AA%8D%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%AE%E3%81%A7%E8%A7%A3%E6%B6%88%E3%81%99%E3%82%8B][VSCodeでgitのconflictを解消させる話 - Qiita]]

上の記事のように Accept Incoming Change とかをクリックし、さらに追記したければその場で修正も可能なので、これを使っています。

*** なんでこうなった？

なんでこうなったのか、よく覚えていません。

ひとつひとつは知ったときに便利だと思って導入したものなんですが、総合すると統一感がないですね。特に tig はごく限られた用途でしか使っていないし、せっかくエディタの統合機能使っているならもっとエディタでこなせばいいじゃんという気持ちにもなります。

とはいえ今の自分はこのちぐはぐなのにこなれてしまったし、意識して変えようとしなければしばらくは変わらなそうな気がします。

コマンドラインでほとんどを済ませるのはデスクトップ Linux にまともな Git クライアントが存在しないからなんですが GitQlient とかは密かに watch していたりします。

[[https://github.com/francescmm/GitQlient][francescmm/GitQlient: GitQlient: Multi-platform Git client written with Qt.]]

そのうち GUI クライアントも使ってみるかもです。
